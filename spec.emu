<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: dynamic modules reform
stage: 0
contributors: Caridy Pati√±o
</pre>

<!-- es6num="9.4.6.8" -->
<emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver">
  <h1>[[Get]] (_P_, _Receiver_)</h1>
  <p>When the [[Get]] internal method of a module namespace exotic object _O_ is called with property key _P_ and ECMAScript language value _Receiver_, the following steps are taken:</p>
  <emu-alg>
    1. Assert: IsPropertyKey(_P_) is *true*.
    1. If Type(_P_) is Symbol, then
      1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).
    1. Let _exports_ be _O_.[[Exports]].
    1. If _P_ is not an element of _exports_, return *undefined*.
    1. Let _m_ be _O_.[[Module]].
    1. Let _binding_ be ! _m_.ResolveExport(_P_, &laquo; &raquo;, &laquo; &raquo;).
    1. <del>Assert: _binding_ is neither *null* nor `"ambiguous"`.</del>
    1. <ins>If _binding_ is "pending" or _binding_ is *null* or resolution is "ambiguous", throw a *SyntaxError* exception.</ins>
    1. Let _targetModule_ be _binding_.[[Module]].
    1. Assert: _targetModule_ is not *undefined*.
    1. Let _targetEnv_ be _targetModule_.[[Environment]].
    1. If _targetEnv_ is *undefined*, throw a *ReferenceError* exception.
    1. Let _targetEnvRec_ be _targetEnv_'s EnvironmentRecord.
    1. Return ? _targetEnvRec_.GetBindingValue(_binding_.[[BindingName]], *true*).
  </emu-alg>
  <emu-note>
    <p>ResolveExport is idempotent and side-effect free. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each module namespace exotic object.</p>
  </emu-note>
</emu-clause>

<!-- es6num="8.1.1.5.5" -->
<emu-clause id="sec-createimportbinding">
  <h1>CreateImportBinding (_N_, _M_, _N2_)</h1>
  <p>The concrete Environment Record method CreateImportBinding for module Environment Records creates a new initialized immutable indirect binding for the name _N_. A binding must not already exist in this Environment Record for _N_. _M_ is a Module Record, and _N2_ is the name of a binding that <ins>has to exist</ins><del>exists</del> in M's module Environment Record<ins> after _M_ is evaluated</ins>. Accesses to the value of the new binding will indirectly access the bound value of the target binding.</p>

  <emu-alg>
  1. Let _envRec_ be the module Environment Record for which the method was invoked.
  1. Assert: _envRec_ does not already have a binding for _N_.
  1. Assert: _M_ is a Module Record.
  1. <ins>Assert: _M_ is an instantiated Module Record.</ins>
  1. <del>Assert: When _M_.[[Environment]] is instantiated it will have a direct binding for _N2_.<del>
  1. <ins>Assert: If _M_ is a Source Text Module Record, then _M_.[[Environment]] has a direct binding for _N2_.<ins>
  1. Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.
  1. Return NormalCompletion(~empty~).
  </emu-alg>
</emu-clause>

<!-- es6num="15.2.1.16.3" -->
<emu-clause id="sec-resolveexport">
  <h1>ResolveExport( _exportName_, _resolveSet_, _exportStarSet_ ) Concrete Method</h1>
  <p>The ResolveExport concrete method of a Source Text Module Record with arguments _exportName_, _resolveSet_, and _exportStarSet_ performs the following steps:</p>
  <emu-alg>
    1. Let _module_ be this Source Text Module Record.
    1. For each Record {[[Module]], [[ExportName]]} _r_ in _resolveSet_, do:
      1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then
        1. Assert: This is a circular import request.
        1. Return *null*.
    1. Append the Record {[[Module]]: _module_, [[ExportName]]: _exportName_} to _resolveSet_.
    1. For each ExportEntry Record _e_ in _module_.[[LocalExportEntries]], do
      1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
        1. Assert: _module_ provides the direct binding for this export.
        1. Return Record{[[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]]}.
    1. For each ExportEntry Record _e_ in _module_.[[IndirectExportEntries]], do
      1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
        1. Assert: _module_ imports a specific binding for this export.
        1. Let _importedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).
        1. Return ? _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_, _exportStarSet_).
    1. If SameValue(_exportName_, `"default"`) is *true*, then
      1. Assert: A `default` export was not explicitly defined by this module.
      1. Return *null*.
      1. NOTE A `default` export cannot be provided by an `export *`.
    1. If _exportStarSet_ contains _module_, return *null*.
    1. Append _module_ to _exportStarSet_.
    1. Let _starResolution_ be *null*.
    1. For each ExportEntry Record _e_ in _module_.[[StarExportEntries]], do
      1. Let _importedModule_ be ? HostResolveImportedModule(_module_, _e_.[[ModuleRequest]]).
      1. Let _resolution_ be ? _importedModule_.ResolveExport(_exportName_, _resolveSet_, _exportStarSet_).
      1. If _resolution_ is `"ambiguous"`, return `"ambiguous"`.
      1. <ins>If _resolution_ is `"pending"`, return `"pending"`.</ins>
      1. If _resolution_ is not *null*, then
        1. If _starResolution_ is *null*, let _starResolution_ be _resolution_.
        1. Else,
          1. Assert: There is more than one `*` import that includes the requested name.
          1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record or SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return `"ambiguous"`.
    1. Return _starResolution_.
  </emu-alg>
  <emu-note>
    <p>ResolveExport attempts to resolve an imported binding to the actual defining module and local binding name. The defining module may be the module represented by the Module Record this method was invoked on or some other module that is imported by that module. The parameter _resolveSet_ is use to detect unresolved circular import/export paths. If a pair consisting of specific Module Record and _exportName_ is reached that is already in _resolveSet_, an import circularity has been encountered. Before recursively calling ResolveExport, a pair consisting of _module_ and _exportName_ is added to _resolveSet_.</p>
    <p>If a defining module is found a Record {[[Module]], [[BindingName]]} is returned. This record identifies the resolved binding of the originally requested export. If no definition was found or the request is found to be circular, *null* is returned. If the request is found to be ambiguous, the string `"ambiguous"` is returned.<ins> If the request is found to be pending, the string `"pending"` is returned.</ins></p>
  </emu-note>
</emu-clause>
